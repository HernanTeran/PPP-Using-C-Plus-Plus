* There are three storage classes: automatic storage, static storage, and free store (heap) storage.

* Automatic storage: variables defined in functions(including function parameters) are placed in automatic storage(on the stack) unless
  explicitly declared as static. Automatic storage is allocated when a function is called and deallocated when a call returns; thus, if a function is 
  directly or indirectly called by itself, multiple copies of automatic data can exist: one for each call.
  
* Static storage: variables declared in global and namespace scope are stored in static storage, as are variables explicitly declared static in functions
  and classes. The linker allocates static storage before the program starts running.
  
* Free store (heap) storage: objects created by new are allocated in the free store.

* Overload resolution: the process of choosing a function to call based on a set of arguments. The compiler is responsible for which overloaded function
  gets used. 
  
* the tilde in a destructor ~ is called the complement operator

* :: is the scope resolution operator

* understand you should first collect data into a general structure like a vector than can be used for many things 
  and then you can use that for a particular application like in a multimap. A class is for objects, structs are for data, structs
  can contain vectors of objects that are related. An iterator can also be defined in the struct for clarity.
  Example: using Mess_it = vector<Messages>::const_iterator;
           Mess_iter begin() const { return m.begin(); }
           Mess_iter end() const { return m.end(); }
           
// C++ Using Data Abstraction & Procedural Programming
// C++ Using Object-Oriented Programming
// C Programming
// C++ Using Generic Programming

// namespace (make header namespace.h)
// enum class (before class is defined)
// class
// private:
// data members
// public:
// class Invalid{}
// constructors
// outside of class definition:
// nonmodifying/modifying operations
// bool is_valid(same parameters as constructor) function
// is_valid returns true and has multiple returns for false
// overloaded operators
// Class_Object functions(const Class& c);
// helper functions
------------------------------------------------------------------------------
destructor use example
------------------------------------------------------------------------------
class A
{
    char *someHeapMemory;
public:
    A() : someHeapMemory(new char[1000]) {}
    ~A() { delete[] someHeapMemory; }
};

class B
{
    A* APtr;
public:
    B() : APtr(new A()) {}
    ~B() { delete APtr; }
};

class C
{
    A Amember;
public:
    C() : Amember() {}
    ~C() {} // A is freed / destructed automatically.
};

int main()
{
    B* BPtr = new B();
    delete BPtr; // Calls ~B() which calls ~A() 
    C *CPtr = new C();
    delete CPtr;
    B b;
    C c;
} // b and c are freed/destructed automatically
--------------------------------------------------------------------------------

* Use template<typename T> with classes
  Use template<class T> with functions
  
* Using the keyword using defines an alias for a name. This alias is a symbloc name. It works just like typedef from C.
  Example: using Pint = int*; // Pint means pointer to int ... using Pchar = char*; ... Pchar p = "somehthing"; 
  
* std::fixed gives a floating-point format dddd.dd

* std::scientific gives a scientific format d.ddddEdd

--------------------------------------------------------------------------------
// file path: practice -> out -> build -> x64 -> practice


void error(const string& s);
// catch std::exception& for potential out-of-range errors
// catch std::runtime_error& for everything else with the error() function
void error(const string& s)
{
	throw std::runtime_error(s);
}

// use constexpr functions to have the function evaluated at compile time
// instead of run time. Must use constexpr arguments

// use a static const initializer function for default constructor

// using enums instead of enum classes are fine just make sure
// that you are using the correct values and have names that won't conflict with others

// stream state: good(), eof(), fail(), bad()
// use cin.clear() after cin.fail() or (!cin)

// so far void function to fill using istream

// defining the input operator >> requires testing for (!is) by doing:
// (!is) return is;			or
// if (...) is.clear(ios_base::failbit) return is;

// fstream can be used for input and output instead of ifstream and ofstream

// istringstream is useful for string to numeric value
// ostringstream is useful for formatting output especially for log files
// ex:
// int seq_no = get_next_number();
// ostringstream name;
// name << "myfile" << seq_no << ".log"; // concatenation
// ofstream logfile{name.str()};

// getline is only useful if the input is full of commands
// that were separated by white space
// otherwise use stringstream ss >> and read input individually

// EXAMPLE (with simple input like this read with cin individually):
// string name;
// string first_name;
// string last_name;
// getline(cin, name); uses getline to get the line containing name
// stringstream ss{ name }; // ss separates by whitespace and holds the contents of name
// ss >> first_name; // ss reads the first word into a string
// ss >> last_name; // and so on
// cout << ss.str() << '\n'; this outputs the original input
// cout << first_name << '\n'; // read from ss
// cout << last_name << '\n';

// EXAMPLE (with commands or long text use a vector to hold each individual word):
// string command;
// getline(cin, command);
// stringstream ss{command};
// vector<string> words;
// for (string s; ss >> s;) words.push_back(s);

// remember to use initializer_list<T> t for types that should have lists
// abstract classes are classes that can only be used as a base class
// classes are made abstract by making constructors protected or using a pure virtual function
// use protected for functions that the make sense only for derived classes but
// use an important object creation concept
// delete a base class's copy constructor, copy assignment operator, and default constructor

// BINARY FILES
// file type: f.dat
// ofstream os{file, ios::binary};
// to write binary: fileObject.write(address, size)
// file.write(&var, sizeof(var));
// to read binary: fileObject.read(address, size)
// file.read(&var, sizeof(var));
// !!! However this only works for char so you must convert 
// other data types into char using file.write(reinterpret_cast<char*>(&var), sizeof(var));
